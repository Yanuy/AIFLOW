<!DOCTYPE html>
<html lang=zh-CN>
<meta charset=UTF-8>
<meta content="width=device-width,initial-scale=1" name=viewport>
<title>æ•°æ®åˆ†æç³»ç»Ÿ</title>
<script src=https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/lib/ml-matrix.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/ml-kmeans@6.0.0/lib/ml-kmeans.min.js></script>
<style>
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
        background: #fff;
        color: #333;
        min-height: 100vh
    }

    .header {
        background: linear-gradient(135deg, #0066b3 0, #004d87 100%);
        padding: 20px;
        box-shadow: 0 4px 20px rgba(0, 102, 179, .2);
        border-bottom: 1px solid #e0e7ed;
        position: relative
    }

    .back-button {
        position: absolute;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(255, 255, 255, .1);
        border: 1px solid rgba(255, 255, 255, .3);
        color: #fff;
        padding: 8px 16px;
        border-radius: 6px;
        text-decoration: none;
        font-size: 20px;
        font-weight: 500;
        transition: all .3s ease;
        backdrop-filter: blur(5px)
    }

    .back-button:hover {
        background: rgba(255, 255, 255, .2);
        border-color: rgba(255, 255, 255, .5);
        transform: translateY(calc(-50% - 1px));
        box-shadow: 0 4px 12px rgba(0, 0, 0, .15)
    }

    .back-button:active {
        transform: translateY(-50%);
        transition: none
    }

    .header h1 {
        font-size: 28px;
        background: linear-gradient(135deg, #fff 0, #f0f8ff 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
        letter-spacing: 2px;
        margin-bottom: 20px
    }

    .step-navigator {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 20px
    }

    .step-nav-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 20px;
        background: rgba(255, 255, 255, .1);
        border: 1px solid rgba(255, 255, 255, .3);
        border-radius: 25px;
        cursor: pointer;
        transition: all .3s ease;
        color: rgba(255, 255, 255, .8);
        text-decoration: none;
        min-width: 180px
    }

    .step-nav-item:hover {
        background: rgba(255, 255, 255, .15);
        border-color: rgba(255, 255, 255, .5);
        color: #fff;
        transform: translateY(-1px)
    }

    .step-nav-item.active {
        background: #fff;
        color: #0066b3;
        border-color: transparent;
        box-shadow: 0 4px 15px rgba(0, 0, 0, .1)
    }

    .step-nav-item.completed {
        background: rgba(74, 222, 128, .2);
        border-color: rgba(74, 222, 128, .5);
        color: rgba(255, 255, 255, .9)
    }

    .step-nav-number {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background: rgba(255, 255, 255, .2);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: 700;
        flex-shrink: 0
    }

    .step-nav-item.active .step-nav-number {
        background: #0066b3;
        color: #fff
    }

    .step-nav-item.completed .step-nav-number {
        background: #22c55e;
        color: #fff
    }

    .step-nav-text {
        display: flex;
        flex-direction: column
    }

    .step-nav-title {
        font-weight: 600;
        font-size: 14px
    }

    .step-nav-desc {
        font-size: 12px;
        opacity: .8
    }

    .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px
    }

    .step-container {
        display: block;
        margin-bottom: 30px;
        opacity: .5;
        transition: all .3s ease;
        pointer-events: none
    }

    .step-container.active {
        opacity: 1;
        pointer-events: auto
    }

    .step-container.completed {
        opacity: .8;
        pointer-events: auto
    }

    .step-header {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 30px;
        padding: 20px;
        background: #f8fafc;
        border-radius: 12px;
        border: 1px solid #e0e7ed;
        cursor: pointer;
        transition: all .3s ease
    }

    .step-container.active .step-header {
        background: linear-gradient(135deg, #f0f8ff 0, #e6f3ff 100%);
        border-color: #0066b3;
        box-shadow: 0 4px 15px rgba(0, 102, 179, .1)
    }

    .step-container.completed .step-header {
        background: linear-gradient(135deg, #f0fdf4 0, #e6ffea 100%);
        border-color: #22c55e
    }

    .step-number {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: linear-gradient(135deg, #6c757d 0, #495057 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        font-weight: 700;
        color: #fff;
        transition: all .3s ease
    }

    .step-container.active .step-number {
        background: linear-gradient(135deg, #0066b3 0, #004d87 100%)
    }

    .step-container.completed .step-number {
        background: linear-gradient(135deg, #22c55e 0, #16a34a 100%)
    }

    .step-title {
        font-size: 24px;
        color: #666;
        transition: all .3s ease
    }

    .step-container.active .step-title {
        color: #0066b3
    }

    .step-container.completed .step-title {
        color: #22c55e
    }

    .step-description {
        color: #999
    }

    .card {
        background: #fff;
        border: 1px solid #e0e7ed;
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 20px;
        box-shadow: 0 2px 8px rgba(0, 102, 179, .05);
        transition: all .3s ease
    }

    .step-container.active .card {
        border-color: #0066b3;
        box-shadow: 0 4px 20px rgba(0, 102, 179, .1)
    }

    .file-upload-area {
        border: 2px dashed #e0e7ed;
        border-radius: 12px;
        padding: 50px;
        text-align: center;
        cursor: pointer;
        transition: all .3s ease;
        background: #f8fafc
    }

    .file-upload-area.dragover,
    .file-upload-area:hover {
        border-color: #0066b3;
        background: #f0f8ff
    }

    .file-upload-icon {
        font-size: 48px;
        margin-bottom: 20px;
        color: #0066b3
    }

    .btn {
        padding: 12px 25px;
        background: linear-gradient(135deg, #0066b3 0, #004d87 100%);
        color: #fff;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all .3s ease;
        box-shadow: 0 4px 15px rgba(0, 102, 179, .3);
        text-transform: uppercase;
        letter-spacing: 1px
    }

    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 102, 179, .4)
    }

    .btn-secondary {
        background: linear-gradient(135deg, #6c757d 0, #495057 100%);
        box-shadow: 0 4px 15px rgba(108, 117, 125, .3)
    }

    .btn-secondary:hover {
        box-shadow: 0 6px 20px rgba(108, 117, 125, .4)
    }

    .btn-success {
        background: linear-gradient(135deg, #4ade80 0, #22c55e 100%);
        box-shadow: 0 4px 15px rgba(74, 222, 128, .3)
    }

    .btn-success:hover {
        box-shadow: 0 6px 20px rgba(74, 222, 128, .4)
    }

    .btn-danger {
        background: linear-gradient(135deg, #f093fb 0, #f5576c 100%);
        box-shadow: 0 4px 15px rgba(245, 87, 108, .3)
    }

    .btn-danger:hover {
        box-shadow: 0 6px 20px rgba(245, 87, 108, .4)
    }

    .data-preview {
        max-height: 400px;
        overflow: auto;
        background: #f8fafc;
        border-radius: 8px;
        border: 1px solid #e0e7ed
    }

    .data-table {
        width: 100%;
        border-collapse: collapse
    }

    .data-table td,
    .data-table th {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #e0e7ed
    }

    .data-table th {
        background: #fff;
        color: #0066b3;
        font-weight: 600;
        position: sticky;
        top: 0;
        border-bottom: 2px solid #0066b3
    }

    .variable-config {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 20px;
        margin-top: 20px
    }

    .variable-section {
        background: #f8fafc;
        border-radius: 8px;
        padding: 20px;
        border: 1px solid #e0e7ed
    }

    .variable-section h3 {
        color: #0066b3;
        margin-bottom: 15px;
        font-size: 18px
    }

    .variable-list {
        max-height: 300px;
        overflow-y: auto
    }

    .variable-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px;
        margin: 5px 0;
        background: #fff;
        border-radius: 6px;
        cursor: pointer;
        transition: all .3s ease;
        border: 1px solid #e0e7ed
    }

    .variable-item:hover {
        background: #f0f8ff;
        border-color: #0066b3
    }

    .variable-item.selected {
        background: #f0f8ff;
        border: 1px solid #0066b3;
        box-shadow: 0 2px 8px rgba(0, 102, 179, .1)
    }

    .algorithm-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-top: 20px
    }

    .algorithm-card {
        background: #f8fafc;
        border: 1px solid #e0e7ed;
        border-radius: 12px;
        padding: 20px;
        cursor: pointer;
        transition: all .3s ease;
        position: relative
    }

    .algorithm-card:hover {
        border-color: #0066b3;
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(0, 102, 179, .15)
    }

    .algorithm-card.selected {
        border-color: #0066b3;
        background: #f0f8ff;
        box-shadow: 0 4px 15px rgba(0, 102, 179, .1)
    }

    .algorithm-card h3 {
        color: #0066b3;
        margin-bottom: 10px
    }

    .algorithm-card p {
        color: #666;
        font-size: 14px;
        line-height: 1.5
    }

    .parameters-section {
        display: none;
        margin-top: 20px;
        padding: 20px;
        background: #f8fafc;
        border-radius: 8px;
        border: 1px solid #e0e7ed
    }

    .parameters-section.active {
        display: block
    }

    .param-group {
        margin-bottom: 20px
    }

    .param-group label {
        display: block;
        margin-bottom: 8px;
        color: #666;
        font-weight: 500
    }

    input,
    select,
    textarea {
        width: 100%;
        padding: 10px;
        background: #fff;
        color: #333;
        border: 1px solid #e0e7ed;
        border-radius: 6px;
        font-size: 14px;
        transition: all .3s ease
    }

    input:focus,
    select:focus,
    textarea:focus {
        outline: 0;
        border-color: #0066b3;
        box-shadow: 0 0 0 3px rgba(0, 102, 179, .1)
    }

    .progress-bar {
        width: 100%;
        height: 8px;
        background: #e0e7ed;
        border-radius: 4px;
        overflow: hidden;
        margin: 20px 0
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(135deg, #0066b3 0, #004d87 100%);
        width: 0%;
        transition: width .3s ease
    }

    .rules-output {
        background: #f8fafc;
        border: 1px solid #e0e7ed;
        border-radius: 8px;
        max-height: 500px;
        overflow-y: auto
    }

    .rule-item {
        padding: 15px;
        border-bottom: 1px solid #e0e7ed;
        transition: all .3s ease;
        background: #fff;
        margin: 8px;
        border-radius: 8px;
        border: 1px solid #e0e7ed
    }

    .rule-item:hover {
        background: #f0f8ff;
        border-color: #0066b3;
        box-shadow: 0 2px 8px rgba(0, 102, 179, .1)
    }

    .rule-item:last-child {
        border-bottom: 1px solid #e0e7ed
    }

    .rule-name {
        color: #0066b3;
        font-weight: 600;
        font-size: 16px
    }

    .rule-confidence {
        background: rgba(74, 222, 128, .15);
        color: #22c55e;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        margin-left: auto
    }

    .rule-conditions {
        color: #333;
        font-family: Consolas, Monaco, monospace;
        font-size: 14px;
        line-height: 1.5
    }

    .step-navigation {
        display: none
    }

    .loading {
        display: none;
        text-align: center;
        padding: 40px
    }

    .loading.active {
        display: block
    }

    .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(0, 102, 179, .1);
        border-top: 5px solid #0066b3;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px
    }

    @keyframes spin {
        0% {
            transform: rotate(0)
        }

        100% {
            transform: rotate(360deg)
        }
    }

    .export-section {
        margin-top: 30px;
        padding: 20px;
        background: #f8fafc;
        border-radius: 12px;
        border: 1px solid #e0e7ed
    }

    .export-options {
        display: flex;
        gap: 15px;
        margin-top: 15px
    }

    .auto-load-indicator {
        background: linear-gradient(135deg, #4ade80 0, #22c55e 100%);
        color: #fff;
        padding: 10px 20px;
        border-radius: 8px;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 14px
    }

    @media (max-width:768px) {
        .variable-config {
            grid-template-columns: 1fr
        }

        .algorithm-grid {
            grid-template-columns: 1fr
        }

        .step-navigator {
            flex-direction: column;
            gap: 10px
        }

        .step-nav-item {
            min-width: auto
        }
    }
</style>
<div class=header><a class=back-button href=index.html>è¿”å›ä¸»ç³»ç»Ÿ</a>
    <h1>æ•°æ®åˆ†æç³»ç»Ÿ</h1>
    <div class=step-navigator>
        <div class="step-nav-item active" data-step=1>
            <div class=step-nav-number>1</div>
            <div class=step-nav-text>
                <div class=step-nav-title>æ•°æ®ä¸Šä¼ </div>
                <div class=step-nav-desc>ä¸Šä¼ äº¤æ˜“æ•°æ®æ–‡ä»¶</div>
            </div>
        </div>
        <div class=step-nav-item data-step=2>
            <div class=step-nav-number>2</div>
            <div class=step-nav-text>
                <div class=step-nav-title>å˜é‡é…ç½®</div>
                <div class=step-nav-desc>é€‰æ‹©ç›®æ ‡å’Œç‰¹å¾å˜é‡</div>
            </div>
        </div>
        <div class=step-nav-item data-step=3>
            <div class=step-nav-number>3</div>
            <div class=step-nav-text>
                <div class=step-nav-title>ç®—æ³•é€‰æ‹©</div>
                <div class=step-nav-desc>é€‰æ‹©è§„åˆ™ç”Ÿæˆç®—æ³•</div>
            </div>
        </div>
        <div class=step-nav-item data-step=4>
            <div class=step-nav-number>4</div>
            <div class=step-nav-text>
                <div class=step-nav-title>è§„åˆ™ç”Ÿæˆ</div>
                <div class=step-nav-desc>ç”Ÿæˆå’ŒæŸ¥çœ‹è§„åˆ™</div>
            </div>
        </div>
    </div>
</div>
<div class=container>
    <div class="step-container active" id=step1>
        <div class=step-header onclick=switchToStep(1)>
            <div class=step-number>1</div>
            <div>
                <div class=step-title>æ•°æ®ä¸Šä¼ </div>
                <div class=step-description>ä¸Šä¼ æ‚¨çš„äº¤æ˜“æ•°æ®æ–‡ä»¶ï¼Œæ”¯æŒ CSVã€Excel æ ¼å¼</div>
            </div>
        </div>
        <div class=card>
            <div class=auto-load-indicator id=autoLoadIndicator>âœ… å·²è‡ªåŠ¨åŠ è½½ç¤ºä¾‹æ•°æ®é›† - åŒ…å«1000æ¡å¯ç–‘äº¤æ˜“è®°å½•</div>
            <div class=file-upload-area id=fileUploadArea>
                <div class=file-upload-icon>ğŸ“Š</div>
                <h3>æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</h3>
                <p style=margin-top:10px;color:#a0a0a0>æ”¯æŒ CSVã€Excel (xlsx, xls) æ ¼å¼
                <div style=margin-top:15px><button class="btn btn-secondary" onclick=loadSampleData()>ğŸ”„
                        é‡æ–°åŠ è½½ç¤ºä¾‹æ•°æ®</button> <a class="btn btn-secondary" href=sample_transaction_data.csv download
                        style="text-decoration:none;font-size:12px;padding:8px 15px;margin-left:10px">ğŸ“¥ ä¸‹è½½ç¤ºä¾‹æ•°æ®</a>
                </div><input id=fileInput type=file accept=.csv,.xlsx,.xls style=display:none>
            </div>
            <div id=fileInfo style=margin-top:20px>
                <h4 style=color:#0066b3;margin-bottom:10px>æ–‡ä»¶ä¿¡æ¯</h4>
                <div id=fileDetails></div>
            </div>
            <div id=dataPreview style=margin-top:20px>
                <h4 style=color:#0066b3;margin-bottom:15px>æ•°æ®é¢„è§ˆ</h4>
                <div class=data-preview>
                    <table class=data-table id=previewTable></table>
                </div>
            </div>
        </div>
    </div>
    <div class=step-container id=step2>
        <div class=step-header onclick=switchToStep(2)>
            <div class=step-number>2</div>
            <div>
                <div class=step-title>å˜é‡é…ç½®</div>
                <div class=step-description>é€‰æ‹©ç›®æ ‡å˜é‡ã€ç‰¹å¾å˜é‡å’Œæ’é™¤å˜é‡</div>
            </div>
        </div>
        <div class=card>
            <div class=variable-config>
                <div class=variable-section>
                    <h3>ğŸ¯ ç›®æ ‡å˜é‡</h3>
                    <p style=color:#a0a0a0;margin-bottom:15px;font-size:14px>é€‰æ‹©è¦é¢„æµ‹çš„å˜é‡ï¼ˆå¦‚ï¼šæ˜¯å¦å¯ç–‘ã€é£é™©ç­‰çº§ç­‰ï¼‰
                    <div class=variable-list id=targetVariables></div>
                </div>
                <div class=variable-section>
                    <h3>ğŸ“‹ ç‰¹å¾å˜é‡</h3>
                    <p style=color:#a0a0a0;margin-bottom:15px;font-size:14px>é€‰æ‹©ç”¨äºç”Ÿæˆè§„åˆ™çš„ç‰¹å¾å˜é‡
                    <div class=variable-list id=featureVariables></div>
                </div>
                <div class=variable-section>
                    <h3>ğŸš« æ’é™¤å˜é‡</h3>
                    <p style=color:#a0a0a0;margin-bottom:15px;font-size:14px>æ’é™¤ä¸å‚ä¸è§„åˆ™ç”Ÿæˆçš„å˜é‡ï¼ˆå¦‚ï¼šIDã€æ—¶é—´æˆ³ç­‰ï¼‰
                    <div class=variable-list id=excludeVariables></div>
                </div>
            </div>
        </div>
    </div>
    <div class=step-container id=step3>
        <div class=step-header onclick=switchToStep(3)>
            <div class=step-number>3</div>
            <div>
                <div class=step-title>ç®—æ³•é€‰æ‹©</div>
                <div class=step-description>é€‰æ‹©è§„åˆ™ç”Ÿæˆç®—æ³•å¹¶è®¾ç½®å‚æ•°</div>
            </div>
        </div>
        <div class=card>
            <h3 style=color:#0066b3;margin-bottom:20px>é€‰æ‹©ç®—æ³•</h3>
            <div class=algorithm-grid>
                <div class=algorithm-card data-algorithm=decision_tree>
                    <h3>ğŸŒ³ å†³ç­–æ ‘</h3>
                    <p>é€šè¿‡å†³ç­–æ ‘æ¨¡å‹ç”Ÿæˆif-thenè§„åˆ™ï¼Œå…·æœ‰è‰¯å¥½çš„å¯è§£é‡Šæ€§ã€‚é€‚ç”¨äºåˆ†ç±»å’Œå›å½’é—®é¢˜ï¼Œèƒ½å¤Ÿå¤„ç†æ•°å€¼å‹å’Œåˆ†ç±»å‹ç‰¹å¾ã€‚
                </div>
                <div class=algorithm-card data-algorithm=association_rules>
                    <h3>ğŸ”— å…³è”è§„åˆ™</h3>
                    <p>å‘ç°æ•°æ®é¡¹ä¹‹é—´çš„é¢‘ç¹å…³è”æ¨¡å¼ã€‚ä½¿ç”¨æ”¯æŒåº¦ã€ç½®ä¿¡åº¦å’Œæå‡åº¦ç­‰æŒ‡æ ‡æ¥è¯„ä¼°è§„åˆ™è´¨é‡ã€‚
                </div>
                <div class=algorithm-card data-algorithm=clustering>
                    <h3>ğŸ¯ èšç±»åˆ†æ</h3>
                    <p>é€šè¿‡K-meansç­‰èšç±»ç®—æ³•å‘ç°æ•°æ®çš„è‡ªç„¶åˆ†ç»„ï¼Œç„¶åä¸ºæ¯ä¸ªèšç±»ç”Ÿæˆç‰¹å¾æè¿°è§„åˆ™ã€‚
                </div>
                <div class=algorithm-card data-algorithm=random_forest>
                    <h3>ğŸŒ² éšæœºæ£®æ—</h3>
                    <p>åŸºäºå¤šä¸ªå†³ç­–æ ‘çš„é›†æˆå­¦ä¹ æ–¹æ³•ï¼Œæå–ç‰¹å¾é‡è¦æ€§å¹¶ç”Ÿæˆæ›´ç¨³å®šçš„è§„åˆ™ã€‚
                </div>
            </div>
            <div class=parameters-section id=decision_tree_params>
                <h4 style=color:#0066b3;margin-bottom:15px>å†³ç­–æ ‘å‚æ•°è®¾ç½®</h4>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">
                    <div class=param-group><label>æœ€å¤§æ·±åº¦</label> <input id=max_depth type=number max=20 min=1 value=5>
                    </div>
                    <div class=param-group><label>æœ€å°æ ·æœ¬åˆ†å‰²</label> <input id=min_samples_split type=number max=100 min=2
                            value=10></div>
                    <div class=param-group><label>æœ€å°æ ·æœ¬å¶å­</label> <input id=min_samples_leaf type=number max=50 min=1
                            value=5></div>
                    <div class=param-group><label>åˆ†å‰²æ ‡å‡†</label> <select id=criterion>
                            <option value=gini>åŸºå°¼ç³»æ•°
                            <option value=entropy>ä¿¡æ¯ç†µ
                        </select></div>
                </div>
            </div>
            <div class=parameters-section id=association_rules_params>
                <h4 style=color:#0066b3;margin-bottom:15px>å…³è”è§„åˆ™å‚æ•°è®¾ç½®</h4>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:20px">
                    <div class=param-group><label>æœ€å°æ”¯æŒåº¦</label> <input id=min_support type=number max=1 min=0.01
                            value=0.1 step=0.01></div>
                    <div class=param-group><label>æœ€å°ç½®ä¿¡åº¦</label> <input id=min_confidence type=number max=1 min=0.01
                            value=0.5 step=0.01></div>
                    <div class=param-group><label>æœ€å°æå‡åº¦</label> <input id=min_lift type=number max=10 min=0.1 value=1.0
                            step=0.1></div>
                </div>
            </div>
            <div class=parameters-section id=clustering_params>
                <h4 style=color:#0066b3;margin-bottom:15px>èšç±»åˆ†æå‚æ•°è®¾ç½®</h4>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">
                    <div class=param-group><label>èšç±»æ•°é‡</label> <input id=n_clusters type=number max=20 min=2 value=5>
                    </div>
                    <div class=param-group><label>èšç±»ç®—æ³•</label> <select id=clustering_method>
                            <option value=kmeans>K-Means
                            <option value=dbscan>DBSCAN
                            <option value=hierarchical>å±‚æ¬¡èšç±»
                        </select></div>
                </div>
            </div>
            <div class=parameters-section id=random_forest_params>
                <h4 style=color:#0066b3;margin-bottom:15px>éšæœºæ£®æ—å‚æ•°è®¾ç½®</h4>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">
                    <div class=param-group><label>æ ‘çš„æ•°é‡</label> <input id=n_estimators type=number max=500 min=10
                            value=100></div>
                    <div class=param-group><label>æœ€å¤§æ·±åº¦</label> <input id=rf_max_depth type=number max=30 min=1 value=10>
                    </div>
                    <div class=param-group><label>ç‰¹å¾é‡‡æ ·æ¯”ä¾‹</label> <input id=max_features type=number max=1 min=0.1
                            value=0.8 step=0.1></div>
                    <div class=param-group><label>æ ·æœ¬é‡‡æ ·æ¯”ä¾‹</label> <input id=max_samples type=number max=1 min=0.1
                            value=0.8 step=0.1></div>
                </div>
            </div>
            <div style=margin-top:30px;text-align:center><button class=btn onclick=generateRules()>ğŸš€ å¼€å§‹ç”Ÿæˆè§„åˆ™</button>
            </div>
        </div>
    </div>
    <div class=step-container id=step4>
        <div class=step-header onclick=switchToStep(4)>
            <div class=step-number>4</div>
            <div>
                <div class=step-title>è§„åˆ™ç”Ÿæˆ</div>
                <div class=step-description>ç”Ÿæˆå’ŒæŸ¥çœ‹æå–çš„è§„åˆ™</div>
            </div>
        </div>
        <div class=loading id=loadingIndicator>
            <div class=spinner></div>
            <h3 style=color:#0066b3>æ­£åœ¨ç”Ÿæˆè§„åˆ™...</h3>
            <p style=color:#a0a0a0;margin-top:10px>è¯·ç¨å€™ï¼Œè¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿæ—¶é—´
            <div class=progress-bar>
                <div class=progress-fill id=progressFill></div>
            </div>
        </div>
        <div class=card id=resultsCard style=display:none>
            <div style=display:flex;justify-content:space-between;align-items:center;margin-bottom:20px>
                <h3 style=color:#0066b3>ç”Ÿæˆçš„è§„åˆ™</h3>
                <div><span style=color:#4ade80;font-weight:600 id=ruleCount></span> <span style=color:#a0a0a0>æ¡è§„åˆ™</span>
                </div>
            </div>
            <div class=rules-output id=rulesOutput></div>
            <div class=export-section>
                <h4 style=color:#0066b3;margin-bottom:15px>å¯¼å‡ºè§„åˆ™</h4>
                <p style=color:#a0a0a0;margin-bottom:15px>é€‰æ‹©å¯¼å‡ºæ ¼å¼å¹¶å¯¼å…¥åˆ°ä¸»è§„åˆ™ç®¡ç†ç³»ç»Ÿ
                <div class=export-options><button class=btn onclick=exportToMainSystem()>å¯¼å…¥åˆ°ä¸»ç³»ç»Ÿ</button> <button
                        class="btn btn-secondary" onclick=exportAsJSON()>å¯¼å‡ºä¸ºJSON</button> <button
                        class="btn btn-secondary" onclick=exportAsCSV()>å¯¼å‡ºä¸ºCSV</button></div>
            </div>
        </div>
    </div>
</div>
<script>// å…¨å±€å˜é‡
    let currentStep = 1;
    let uploadedData = null;
    let selectedColumns = {
        target: null,
        features: [],
        exclude: []
    };
    let selectedAlgorithm = null;
    let generatedRules = [];
    let stepCompletionStatus = {
        1: false,
        2: false,
        3: false,
        4: false
    };

    // ç¤ºä¾‹æ•°æ®
    const sampleData = {
        headers: ['äº¤æ˜“ID', 'äº¤æ˜“é‡‘é¢', 'äº¤æ˜“æ—¶é—´', 'è´¦æˆ·ç±»å‹', 'äº¤æ˜“åœ°ç‚¹', 'æ˜¯å¦å¯ç–‘', 'é£é™©ç­‰çº§', 'å®¢æˆ·å¹´é¾„', 'å†å²äº¤æ˜“æ¬¡æ•°'],
        data: []
    };

    // ç”Ÿæˆç¤ºä¾‹æ•°æ®
    function generateSampleData() {
        const locations = ['åŒ—äº¬', 'ä¸Šæµ·', 'å¹¿å·', 'æ·±åœ³', 'æ­å·', 'å—äº¬', 'æ­¦æ±‰', 'æˆéƒ½'];
        const accountTypes = ['ä¸ªäººè´¦æˆ·', 'ä¼ä¸šè´¦æˆ·', 'è”åè´¦æˆ·'];
        const timeSlots = ['09:00-12:00', '12:00-18:00', '18:00-22:00', '22:00-09:00'];

        sampleData.data = [];
        for (let i = 1; i <= 1000; i++) {
            const amount = Math.random() < 0.1 ?
                Math.floor(Math.random() * 900000) + 100000 : // 10%é«˜é¢äº¤æ˜“
                Math.floor(Math.random() * 50000) + 1000;     // 90%æ­£å¸¸äº¤æ˜“

            const timeSlot = timeSlots[Math.floor(Math.random() * timeSlots.length)];
            const isSuspicious = (amount > 100000 && timeSlot === '22:00-09:00') ||
                (Math.random() < 0.05); // 5%éšæœºå¯ç–‘

            sampleData.data.push({
                'äº¤æ˜“ID': `T${String(i).padStart(6, '0')}`,
                'äº¤æ˜“é‡‘é¢': amount,
                'äº¤æ˜“æ—¶é—´': timeSlot,
                'è´¦æˆ·ç±»å‹': accountTypes[Math.floor(Math.random() * accountTypes.length)],
                'äº¤æ˜“åœ°ç‚¹': locations[Math.floor(Math.random() * locations.length)],
                'æ˜¯å¦å¯ç–‘': isSuspicious ? 'æ˜¯' : 'å¦',
                'é£é™©ç­‰çº§': isSuspicious ? (Math.random() > 0.5 ? 'é«˜' : 'ä¸­') : 'ä½',
                'å®¢æˆ·å¹´é¾„': Math.floor(Math.random() * 60) + 18,
                'å†å²äº¤æ˜“æ¬¡æ•°': Math.floor(Math.random() * 500) + 1
            });
        }
    }

    // åˆå§‹åŒ–
    function init() {
        setupFileUpload();
        setupAlgorithmSelection();
        setupStepNavigation();
        loadSampleData(); // è‡ªåŠ¨åŠ è½½ç¤ºä¾‹æ•°æ®
        updateStepVisibility();
    }

    // è®¾ç½®æ­¥éª¤å¯¼èˆª
    function setupStepNavigation() {
        document.querySelectorAll('.step-nav-item').forEach(item => {
            item.addEventListener('click', function () {
                const step = parseInt(this.dataset.step);
                switchToStep(step);
            });
        });
    }

    // åˆ‡æ¢æ­¥éª¤
    function switchToStep(step) {
        if (step < 1 || step > 4) return;

        // æ£€æŸ¥å‰ç½®æ­¥éª¤æ˜¯å¦å®Œæˆ
        if (step > 1 && !stepCompletionStatus[step - 1]) {
            alert(`è¯·å…ˆå®Œæˆæ­¥éª¤${step - 1}`);
            return;
        }

        currentStep = step;
        updateStepVisibility();
        updateStepNavigation();

        // æ»šåŠ¨åˆ°å¯¹åº”æ­¥éª¤
        document.getElementById(`step${step}`).scrollIntoView({
            behavior: 'smooth',
            block: 'start'
        });
    }

    // æ›´æ–°æ­¥éª¤å¯è§æ€§
    function updateStepVisibility() {
        document.querySelectorAll('.step-container').forEach((container, index) => {
            const stepNum = index + 1;
            container.classList.remove('active', 'completed');

            if (stepNum === currentStep) {
                container.classList.add('active');
            } else if (stepCompletionStatus[stepNum]) {
                container.classList.add('completed');
            }
        });
    }

    // æ›´æ–°å¯¼èˆªæŒ‡ç¤ºå™¨
    function updateStepNavigation() {
        document.querySelectorAll('.step-nav-item').forEach((item, index) => {
            const stepNum = index + 1;
            item.classList.remove('active', 'completed');

            if (stepNum === currentStep) {
                item.classList.add('active');
            } else if (stepCompletionStatus[stepNum]) {
                item.classList.add('completed');
            }
        });
    }

    // æ ‡è®°æ­¥éª¤å®Œæˆ
    function markStepCompleted(step) {
        stepCompletionStatus[step] = true;
        updateStepVisibility();
        updateStepNavigation();
    }

    // åŠ è½½ç¤ºä¾‹æ•°æ®
    function loadSampleData() {
        generateSampleData();
        uploadedData = sampleData;

        // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
        const fileDetails = document.getElementById('fileDetails');
        fileDetails.innerHTML = `
                <p><strong>æ–‡ä»¶å:</strong> ç¤ºä¾‹äº¤æ˜“æ•°æ®.csv</p>
                <p><strong>æ–‡ä»¶å¤§å°:</strong> ${(JSON.stringify(uploadedData).length / 1024).toFixed(2)} KB</p>
                <p><strong>è¡Œæ•°:</strong> ${uploadedData.data.length}</p>
                <p><strong>åˆ—æ•°:</strong> ${uploadedData.headers.length}</p>
            `;

        displayDataPreview();
        setupVariableSelection();
        markStepCompleted(1);

        // å¦‚æœå½“å‰åœ¨ç¬¬ä¸€æ­¥ï¼Œè‡ªåŠ¨è·³åˆ°ç¬¬äºŒæ­¥
        if (currentStep === 1) {
            setTimeout(() => switchToStep(2), 1000);
        }
    }

    // è®¾ç½®æ–‡ä»¶ä¸Šä¼ 
    function setupFileUpload() {
        const uploadArea = document.getElementById('fileUploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('drop', handleDrop);
        uploadArea.addEventListener('dragleave', handleDragLeave);
        fileInput.addEventListener('change', handleFileSelect);
    }

    function handleDragOver(e) {
        e.preventDefault();
        e.currentTarget.classList.add('dragover');
    }

    function handleDragLeave(e) {
        e.currentTarget.classList.remove('dragover');
    }

    function handleDrop(e) {
        e.preventDefault();
        e.currentTarget.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            processFile(files[0]);
        }
    }

    function handleFileSelect(e) {
        const files = e.target.files;
        if (files.length > 0) {
            processFile(files[0]);
        }
    }

    // å¤„ç†æ–‡ä»¶
    function processFile(file) {
        const reader = new FileReader();

        reader.onload = function (e) {
            const content = e.target.result;

            if (file.name.endsWith('.csv')) {
                uploadedData = parseCSV(content);
            } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                alert('Excelæ–‡ä»¶å¤„ç†åŠŸèƒ½éœ€è¦é¢å¤–çš„åº“æ”¯æŒï¼Œè¯·ä½¿ç”¨CSVæ ¼å¼');
                return;
            }

            displayFileInfo(file);
            displayDataPreview();
            setupVariableSelection();
            markStepCompleted(1);

            // éšè—è‡ªåŠ¨åŠ è½½æŒ‡ç¤ºå™¨
            document.getElementById('autoLoadIndicator').style.display = 'none';
        };

        reader.readAsText(file);
    }

    // è§£æCSV
    function parseCSV(content) {
        const lines = content.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.trim().replace(/['"]/g, ''));
        const data = [];

        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].split(',').map(v => v.trim().replace(/['"]/g, ''));
            const row = {};
            headers.forEach((header, index) => {
                row[header] = values[index] || '';
            });
            data.push(row);
        }

        return { headers, data };
    }

    // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
    function displayFileInfo(file) {
        const fileDetails = document.getElementById('fileDetails');

        fileDetails.innerHTML = `
                <p><strong>æ–‡ä»¶å:</strong> ${file.name}</p>
                <p><strong>æ–‡ä»¶å¤§å°:</strong> ${(file.size / 1024).toFixed(2)} KB</p>
                <p><strong>è¡Œæ•°:</strong> ${uploadedData.data.length}</p>
                <p><strong>åˆ—æ•°:</strong> ${uploadedData.headers.length}</p>
            `;
    }

    // æ˜¾ç¤ºæ•°æ®é¢„è§ˆ
    function displayDataPreview() {
        const table = document.getElementById('previewTable');
        table.innerHTML = ''; // æ¸…ç©ºç°æœ‰å†…å®¹

        // åˆ›å»ºè¡¨å¤´
        const headerRow = table.createTHead().insertRow();
        uploadedData.headers.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            headerRow.appendChild(th);
        });

        // åˆ›å»ºè¡¨ä½“ï¼ˆåªæ˜¾ç¤ºå‰10è¡Œï¼‰
        const tbody = table.createTBody();
        const previewData = uploadedData.data.slice(0, 10);

        previewData.forEach(row => {
            const tr = tbody.insertRow();
            uploadedData.headers.forEach(header => {
                const td = tr.insertCell();
                td.textContent = row[header] || '';
            });
        });
    }

    // è®¾ç½®å˜é‡é€‰æ‹©
    function setupVariableSelection() {
        const targetContainer = document.getElementById('targetVariables');
        const featureContainer = document.getElementById('featureVariables');
        const excludeContainer = document.getElementById('excludeVariables');

        targetContainer.innerHTML = '';
        featureContainer.innerHTML = '';
        excludeContainer.innerHTML = '';

        // é‡ç½®é€‰æ‹©çŠ¶æ€
        selectedColumns = {
            target: null,
            features: [],
            exclude: []
        };

        uploadedData.headers.forEach((header, index) => {
            // ç›®æ ‡å˜é‡ï¼ˆå•é€‰ï¼‰ - è‡ªåŠ¨é€‰æ‹©"æ˜¯å¦å¯ç–‘"
            const targetItem = createVariableItem(header, 'target', header === 'æ˜¯å¦å¯ç–‘');
            targetContainer.appendChild(targetItem);
            if (header === 'æ˜¯å¦å¯ç–‘') {
                selectedColumns.target = header;
            }

            // ç‰¹å¾å˜é‡ï¼ˆå¤šé€‰ï¼‰ - æ’é™¤IDå’Œç›®æ ‡å˜é‡
            const shouldSelectFeature = !header.includes('ID') && header !== 'æ˜¯å¦å¯ç–‘';
            const featureItem = createVariableItem(header, 'feature', shouldSelectFeature);
            featureContainer.appendChild(featureItem);
            if (shouldSelectFeature) {
                selectedColumns.features.push(header);
            }

            // æ’é™¤å˜é‡ï¼ˆå¤šé€‰ï¼‰ - è‡ªåŠ¨é€‰æ‹©ID
            const shouldExclude = header.includes('ID');
            const excludeItem = createVariableItem(header, 'exclude', shouldExclude);
            excludeContainer.appendChild(excludeItem);
            if (shouldExclude) {
                selectedColumns.exclude.push(header);
            }
        });

        // å¦‚æœæœ‰æœ‰æ•ˆé…ç½®ï¼Œæ ‡è®°æ­¥éª¤2å®Œæˆ
        if (selectedColumns.target && selectedColumns.features.length > 0) {
            markStepCompleted(2);
        }
    }

    function createVariableItem(header, type, selected = false) {
        const item = document.createElement('div');
        item.className = `variable-item ${selected ? 'selected' : ''}`;
        item.innerHTML = `
                <input type="${type === 'target' ? 'radio' : 'checkbox'}" 
                       name="${type}_vars" 
                       value="${header}" 
                       ${selected ? 'checked' : ''}
                       onchange="updateVariableSelection('${type}', '${header}', this.checked)">
                <span>${header}</span>
            `;

        item.addEventListener('click', (e) => {
            if (e.target.tagName !== 'INPUT') {
                const input = item.querySelector('input');
                input.click();
            }
        });

        return item;
    }

    function updateVariableSelection(type, variable, checked) {
        if (type === 'target') {
            selectedColumns.target = checked ? variable : null;
            // æ›´æ–°UI
            document.querySelectorAll('#targetVariables .variable-item').forEach(item => {
                item.classList.remove('selected');
            });
            if (checked) {
                event.target.closest('.variable-item').classList.add('selected');
            }
        } else if (type === 'feature') {
            if (checked) {
                if (!selectedColumns.features.includes(variable)) {
                    selectedColumns.features.push(variable);
                }
                // ä»æ’é™¤åˆ—è¡¨ä¸­ç§»é™¤
                selectedColumns.exclude = selectedColumns.exclude.filter(v => v !== variable);
                const excludeInput = document.querySelector(`#excludeVariables input[value="${variable}"]`);
                if (excludeInput) {
                    excludeInput.checked = false;
                    excludeInput.closest('.variable-item').classList.remove('selected');
                }
            } else {
                selectedColumns.features = selectedColumns.features.filter(v => v !== variable);
            }
            event.target.closest('.variable-item').classList.toggle('selected', checked);
        } else if (type === 'exclude') {
            if (checked) {
                if (!selectedColumns.exclude.includes(variable)) {
                    selectedColumns.exclude.push(variable);
                }
                // ä»ç‰¹å¾åˆ—è¡¨ä¸­ç§»é™¤
                selectedColumns.features = selectedColumns.features.filter(v => v !== variable);
                const featureInput = document.querySelector(`#featureVariables input[value="${variable}"]`);
                if (featureInput) {
                    featureInput.checked = false;
                    featureInput.closest('.variable-item').classList.remove('selected');
                }
            } else {
                selectedColumns.exclude = selectedColumns.exclude.filter(v => v !== variable);
            }
            event.target.closest('.variable-item').classList.toggle('selected', checked);
        }

        // æ£€æŸ¥æ­¥éª¤2æ˜¯å¦å®Œæˆ
        if (selectedColumns.target && selectedColumns.features.length > 0) {
            markStepCompleted(2);
        }
    }

    // è®¾ç½®ç®—æ³•é€‰æ‹©
    function setupAlgorithmSelection() {
        document.querySelectorAll('.algorithm-card').forEach(card => {
            card.addEventListener('click', function () {
                // ç§»é™¤å…¶ä»–é€‰ä¸­çŠ¶æ€
                document.querySelectorAll('.algorithm-card').forEach(c => c.classList.remove('selected'));
                document.querySelectorAll('.parameters-section').forEach(p => p.classList.remove('active'));

                // é€‰ä¸­å½“å‰ç®—æ³•
                this.classList.add('selected');
                selectedAlgorithm = this.dataset.algorithm;

                // æ˜¾ç¤ºå¯¹åº”å‚æ•°
                const paramSection = document.getElementById(selectedAlgorithm + '_params');
                if (paramSection) {
                    paramSection.classList.add('active');
                }

                // æ ‡è®°æ­¥éª¤3å®Œæˆ
                markStepCompleted(3);
            });
        });
    }

    // æ•°æ®é¢„å¤„ç†å’Œç‰¹å¾å·¥ç¨‹
    function preprocessData() {
        if (!uploadedData || !selectedColumns.target || selectedColumns.features.length === 0) {
            throw new Error('æ•°æ®æˆ–é€‰æ‹©çš„åˆ—ä¸å®Œæ•´');
        }

        const processedData = [];
        const labelMap = {};
        let labelCounter = 0;

        // å¤„ç†æ•°æ®ï¼Œè½¬æ¢ä¸ºæ•°å€¼æ ¼å¼
        uploadedData.data.forEach(row => {
            const processedRow = {};

            // å¤„ç†ç›®æ ‡å˜é‡
            let targetValue = row[selectedColumns.target];
            if (isNaN(targetValue)) {
                if (!(targetValue in labelMap)) {
                    labelMap[targetValue] = labelCounter++;
                }
                targetValue = labelMap[targetValue];
            } else {
                targetValue = parseFloat(targetValue);
            }
            processedRow.target = targetValue;

            // å¤„ç†ç‰¹å¾å˜é‡
            selectedColumns.features.forEach(feature => {
                let value = row[feature];
                if (value === undefined || value === null || value === '') {
                    value = 0; // å¤„ç†ç¼ºå¤±å€¼
                } else if (isNaN(value)) {
                    // å­—ç¬¦ä¸²ç¼–ç 
                    const key = `${feature}_${value}`;
                    if (!(key in labelMap)) {
                        labelMap[key] = labelCounter++;
                    }
                    value = labelMap[key];
                } else {
                    value = parseFloat(value);
                }
                processedRow[feature] = value;
            });

            processedData.push(processedRow);
        });

        return { data: processedData, labelMap };
    }

    // ç”Ÿæˆè§„åˆ™
    function generateRules() {
        if (!validateStep3()) {
            alert('è¯·å…ˆé€‰æ‹©ç®—æ³•');
            return;
        }

        const loading = document.getElementById('loadingIndicator');
        const results = document.getElementById('resultsCard');

        loading.classList.add('active');
        results.style.display = 'none';

        // åˆ‡æ¢åˆ°æ­¥éª¤4
        switchToStep(4);

        // æ¨¡æ‹Ÿè¿›åº¦
        let progress = 0;
        const progressFill = document.getElementById('progressFill');
        const progressInterval = setInterval(() => {
            progress += Math.random() * 15;
            if (progress > 95) progress = 95;
            progressFill.style.width = progress + '%';
        }, 200);

        // æ¨¡æ‹Ÿè§„åˆ™ç”Ÿæˆ
        setTimeout(() => {
            clearInterval(progressInterval);
            progressFill.style.width = '100%';

            // ç”Ÿæˆæ¨¡æ‹Ÿè§„åˆ™
            generatedRules = generateMockRules();

            setTimeout(() => {
                loading.classList.remove('active');
                displayGeneratedRules();
                results.style.display = 'block';
                markStepCompleted(4);
            }, 500);
        }, 3000);
    }

    function validateStep3() {
        return selectedAlgorithm !== null;
    }

    // å®ç°çœŸå®çš„ç®—æ³•
    function generateMockRules() {
        try {
            const algorithms = {
                'decision_tree': generateDecisionTreeRules,
                'association_rules': generateAssociationRules,
                'clustering': generateClusteringRules,
                'random_forest': generateRandomForestRules
            };

            if (algorithms[selectedAlgorithm]) {
                return algorithms[selectedAlgorithm]();
            }

            return [];
        } catch (error) {
            console.error('è§„åˆ™ç”Ÿæˆé”™è¯¯:', error);
            return [{
                name: "é”™è¯¯",
                conditions: `ç”Ÿæˆè§„åˆ™æ—¶å‡ºé”™: ${error.message}`,
                confidence: 0,
                category: "é”™è¯¯"
            }];
        }
    }

    // ç®€åŒ–çš„å†³ç­–æ ‘å®ç°
    class SimpleDecisionTree {
        constructor(maxDepth = 5, minSamplesSplit = 10) {
            this.maxDepth = maxDepth;
            this.minSamplesSplit = minSamplesSplit;
            this.tree = null;
            this.rules = [];
        }

        gini(y) {
            const counts = {};
            y.forEach(val => counts[val] = (counts[val] || 0) + 1);
            const total = y.length;
            let gini = 1;
            for (const count of Object.values(counts)) {
                gini -= Math.pow(count / total, 2);
            }
            return gini;
        }

        split(X, y, feature, threshold) {
            const leftX = [], leftY = [], rightX = [], rightY = [];
            for (let i = 0; i < X.length; i++) {
                if (X[i][feature] <= threshold) {
                    leftX.push(X[i]);
                    leftY.push(y[i]);
                } else {
                    rightX.push(X[i]);
                    rightY.push(y[i]);
                }
            }
            return { leftX, leftY, rightX, rightY };
        }

        findBestSplit(X, y) {
            let bestGain = 0;
            let bestFeature = null;
            let bestThreshold = null;

            const features = Object.keys(X[0]).filter(f => f !== 'target');

            for (const feature of features) {
                const values = [...new Set(X.map(x => x[feature]))].sort((a, b) => a - b);

                for (let i = 0; i < values.length - 1; i++) {
                    const threshold = (values[i] + values[i + 1]) / 2;
                    const { leftY, rightY } = this.split(X, y, feature, threshold);

                    if (leftY.length === 0 || rightY.length === 0) continue;

                    const parentGini = this.gini(y);
                    const leftGini = this.gini(leftY);
                    const rightGini = this.gini(rightY);
                    const weightedGini = (leftY.length / y.length) * leftGini +
                        (rightY.length / y.length) * rightGini;
                    const gain = parentGini - weightedGini;

                    if (gain > bestGain) {
                        bestGain = gain;
                        bestFeature = feature;
                        bestThreshold = threshold;
                    }
                }
            }

            return { feature: bestFeature, threshold: bestThreshold, gain: bestGain };
        }

        buildTree(X, y, depth = 0) {
            const uniqueClasses = [...new Set(y)];

            if (uniqueClasses.length === 1 ||
                depth >= this.maxDepth ||
                X.length < this.minSamplesSplit) {
                const counts = {};
                y.forEach(val => counts[val] = (counts[val] || 0) + 1);
                const prediction = Object.keys(counts).reduce((a, b) =>
                    counts[a] > counts[b] ? a : b);
                return {
                    type: 'leaf',
                    prediction: prediction,
                    samples: X.length,
                    confidence: counts[prediction] / X.length
                };
            }

            const { feature, threshold, gain } = this.findBestSplit(X, y);

            if (!feature || gain === 0) {
                const counts = {};
                y.forEach(val => counts[val] = (counts[val] || 0) + 1);
                const prediction = Object.keys(counts).reduce((a, b) =>
                    counts[a] > counts[b] ? a : b);
                return {
                    type: 'leaf',
                    prediction: prediction,
                    samples: X.length,
                    confidence: counts[prediction] / X.length
                };
            }

            const { leftX, leftY, rightX, rightY } = this.split(X, y, feature, threshold);

            return {
                type: 'node',
                feature: feature,
                threshold: threshold,
                left: this.buildTree(leftX, leftY, depth + 1),
                right: this.buildTree(rightX, rightY, depth + 1),
                samples: X.length
            };
        }

        extractRules(node, conditions = [], rules = []) {
            if (node.type === 'leaf') {
                const conditionStr = conditions.length > 0 ?
                    `å¦‚æœ ${conditions.join(' ä¸” ')}` : 'é»˜è®¤è§„åˆ™';

                rules.push({
                    name: `å†³ç­–æ ‘è§„åˆ™ ${rules.length + 1}`,
                    conditions: conditionStr,
                    confidence: node.confidence,
                    support: node.samples / this.totalSamples,
                    category: `é¢„æµ‹ç±»åˆ«: ${node.prediction}`
                });
            } else {
                // å·¦å­æ ‘ (<=)
                this.extractRules(node.left,
                    [...conditions, `${node.feature} <= ${node.threshold.toFixed(2)}`],
                    rules);

                // å³å­æ ‘ (>)
                this.extractRules(node.right,
                    [...conditions, `${node.feature} > ${node.threshold.toFixed(2)}`],
                    rules);
            }

            return rules;
        }

        fit(X, y) {
            this.totalSamples = X.length;
            this.tree = this.buildTree(X, y);
            this.rules = this.extractRules(this.tree);
            return this;
        }
    }

    function generateDecisionTreeRules() {
        const { data } = preprocessData();

        if (data.length < 5) {
            return [{
                name: "æ•°æ®ä¸è¶³",
                conditions: "æ•°æ®æ ·æœ¬æ•°é‡å¤ªå°‘ï¼Œæ— æ³•æ„å»ºæœ‰æ•ˆçš„å†³ç­–æ ‘",
                confidence: 0,
                category: "è­¦å‘Š"
            }];
        }

        const maxDepth = parseInt(document.getElementById('max_depth').value) || 5;
        const minSamplesSplit = parseInt(document.getElementById('min_samples_split').value) || 10;

        const X = data.map(row => {
            const features = {};
            selectedColumns.features.forEach(feature => {
                features[feature] = row[feature];
            });
            return features;
        });

        const y = data.map(row => row.target);

        const tree = new SimpleDecisionTree(maxDepth, minSamplesSplit);
        tree.fit(X, y);

        return tree.rules.slice(0, 10); // é™åˆ¶è§„åˆ™æ•°é‡
    }

    // ç®€åŒ–çš„å…³è”è§„åˆ™æŒ–æ˜å®ç°
    class AssociationRules {
        constructor(minSupport = 0.1, minConfidence = 0.5) {
            this.minSupport = minSupport;
            this.minConfidence = minConfidence;
        }

        // å°†è¿ç»­å˜é‡ç¦»æ•£åŒ–
        discretizeFeature(values, feature) {
            const sortedValues = [...values].sort((a, b) => a - b);
            const q1 = sortedValues[Math.floor(sortedValues.length * 0.25)];
            const q3 = sortedValues[Math.floor(sortedValues.length * 0.75)];
            const median = sortedValues[Math.floor(sortedValues.length * 0.5)];

            return values.map(val => {
                if (val <= q1) return `${feature}_ä½`;
                else if (val >= q3) return `${feature}_é«˜`;
                else return `${feature}_ä¸­`;
            });
        }

        // å‡†å¤‡äº‹åŠ¡æ•°æ®
        prepareTransactions(data) {
            const transactions = [];
            const featureNames = selectedColumns.features;

            // ä¸ºæ¯ä¸ªç‰¹å¾è®¡ç®—ç¦»æ•£åŒ–
            const discretizedFeatures = {};
            featureNames.forEach(feature => {
                const values = data.map(row => row[feature]);
                discretizedFeatures[feature] = this.discretizeFeature(values, feature);
            });

            // æ„å»ºäº‹åŠ¡
            data.forEach((row, i) => {
                const transaction = [];
                featureNames.forEach(feature => {
                    transaction.push(discretizedFeatures[feature][i]);
                });

                // æ·»åŠ ç›®æ ‡å˜é‡
                transaction.push(`ç›®æ ‡_${row.target}`);

                transactions.push(transaction);
            });

            return transactions;
        }

        // è®¡ç®—æ”¯æŒåº¦
        calculateSupport(itemset, transactions) {
            const count = transactions.filter(transaction =>
                itemset.every(item => transaction.includes(item))
            ).length;
            return count / transactions.length;
        }

        // ç”Ÿæˆé¢‘ç¹1é¡¹é›†
        generateFrequent1Itemsets(transactions) {
            const itemCounts = {};

            transactions.forEach(transaction => {
                transaction.forEach(item => {
                    itemCounts[item] = (itemCounts[item] || 0) + 1;
                });
            });

            const frequent1 = [];
            for (const [item, count] of Object.entries(itemCounts)) {
                const support = count / transactions.length;
                if (support >= this.minSupport) {
                    frequent1.push({ itemset: [item], support });
                }
            }

            return frequent1;
        }

        // ç”Ÿæˆå€™é€‰é¡¹é›†
        generateCandidates(frequentSets) {
            const candidates = [];

            for (let i = 0; i < frequentSets.length; i++) {
                for (let j = i + 1; j < frequentSets.length; j++) {
                    const set1 = frequentSets[i].itemset;
                    const set2 = frequentSets[j].itemset;

                    // ç®€åŒ–ï¼šåªç”Ÿæˆ2é¡¹é›†
                    if (set1.length === 1 && set2.length === 1) {
                        candidates.push([...set1, ...set2]);
                    }
                }
            }

            return [...new Set(candidates.map(c => JSON.stringify(c.sort())))].map(c => JSON.parse(c));
        }

        // ç”Ÿæˆå…³è”è§„åˆ™
        generateRules(frequentItemsets, transactions) {
            const rules = [];

            frequentItemsets.forEach(itemset => {
                if (itemset.itemset.length < 2) return;

                // å°è¯•ä¸åŒçš„è§„åˆ™ç»„åˆ
                for (let i = 0; i < itemset.itemset.length; i++) {
                    const antecedent = itemset.itemset.filter((_, idx) => idx !== i);
                    const consequent = [itemset.itemset[i]];

                    if (antecedent.length === 0) continue;

                    const antecedentSupport = this.calculateSupport(antecedent, transactions);
                    const confidence = itemset.support / antecedentSupport;

                    if (confidence >= this.minConfidence && antecedentSupport > 0) {
                        // è®¡ç®—æå‡åº¦
                        const consequentSupport = this.calculateSupport(consequent, transactions);
                        const lift = confidence / consequentSupport;

                        rules.push({
                            antecedent,
                            consequent,
                            support: itemset.support,
                            confidence,
                            lift
                        });
                    }
                }
            });

            return rules.sort((a, b) => b.confidence - a.confidence);
        }

        mine(data) {
            const transactions = this.prepareTransactions(data);

            // ç”Ÿæˆé¢‘ç¹1é¡¹é›†
            const frequent1 = this.generateFrequent1Itemsets(transactions);

            // ç”Ÿæˆå€™é€‰2é¡¹é›†
            const candidates2 = this.generateCandidates(frequent1);

            // è®¡ç®—é¢‘ç¹2é¡¹é›†
            const frequent2 = candidates2
                .map(itemset => ({
                    itemset,
                    support: this.calculateSupport(itemset, transactions)
                }))
                .filter(item => item.support >= this.minSupport);

            // ç”Ÿæˆå…³è”è§„åˆ™
            const allFrequent = [...frequent1, ...frequent2];
            return this.generateRules(allFrequent, transactions);
        }
    }

    function generateAssociationRules() {
        const { data } = preprocessData();

        if (data.length < 10) {
            return [{
                name: "æ•°æ®ä¸è¶³",
                conditions: "æ•°æ®æ ·æœ¬æ•°é‡å¤ªå°‘ï¼Œæ— æ³•è¿›è¡Œå…³è”è§„åˆ™æŒ–æ˜",
                confidence: 0,
                category: "è­¦å‘Š"
            }];
        }

        const minSupport = parseFloat(document.getElementById('min_support').value) || 0.1;
        const minConfidence = parseFloat(document.getElementById('min_confidence').value) || 0.5;

        const associationMiner = new AssociationRules(minSupport, minConfidence);
        const rules = associationMiner.mine(data);

        if (rules.length === 0) {
            return [{
                name: "æœªå‘ç°å…³è”è§„åˆ™",
                conditions: "åœ¨å½“å‰å‚æ•°è®¾ç½®ä¸‹æœªå‘ç°æ»¡è¶³æ¡ä»¶çš„å…³è”è§„åˆ™ï¼Œè¯·å°è¯•é™ä½æ”¯æŒåº¦æˆ–ç½®ä¿¡åº¦é˜ˆå€¼",
                confidence: 0,
                category: "ä¿¡æ¯"
            }];
        }

        return rules.slice(0, 8).map((rule, index) => ({
            name: `å…³è”è§„åˆ™ ${index + 1}`,
            conditions: `${rule.antecedent.join(' ä¸” ')} => ${rule.consequent.join(' ä¸” ')}`,
            confidence: rule.confidence,
            support: rule.support,
            lift: rule.lift,
            category: rule.consequent[0].includes('ç›®æ ‡') ? 'ç›®æ ‡é¢„æµ‹' : 'ç‰¹å¾å…³è”'
        }));
    }

    // K-meansèšç±»å®ç°
    class KMeansCluster {
        constructor(k = 3, maxIter = 100) {
            this.k = k;
            this.maxIter = maxIter;
            this.centroids = [];
            this.labels = [];
        }

        distance(a, b) {
            return Math.sqrt(a.reduce((sum, val, i) => sum + Math.pow(val - b[i], 2), 0));
        }

        initializeCentroids(data) {
            this.centroids = [];
            for (let i = 0; i < this.k; i++) {
                const randomIndex = Math.floor(Math.random() * data.length);
                this.centroids.push([...data[randomIndex]]);
            }
        }

        assignClusters(data) {
            this.labels = data.map(point => {
                let minDistance = Infinity;
                let cluster = 0;

                this.centroids.forEach((centroid, i) => {
                    const dist = this.distance(point, centroid);
                    if (dist < minDistance) {
                        minDistance = dist;
                        cluster = i;
                    }
                });

                return cluster;
            });
        }

        updateCentroids(data) {
            const newCentroids = Array(this.k).fill().map(() =>
                Array(data[0].length).fill(0));
            const counts = Array(this.k).fill(0);

            data.forEach((point, i) => {
                const cluster = this.labels[i];
                counts[cluster]++;
                point.forEach((val, j) => {
                    newCentroids[cluster][j] += val;
                });
            });

            this.centroids = newCentroids.map((centroid, i) =>
                counts[i] > 0 ? centroid.map(val => val / counts[i]) : centroid);
        }

        fit(data) {
            this.initializeCentroids(data);

            for (let iter = 0; iter < this.maxIter; iter++) {
                const oldLabels = [...this.labels];
                this.assignClusters(data);
                this.updateCentroids(data);

                // æ£€æŸ¥æ”¶æ•›
                if (JSON.stringify(oldLabels) === JSON.stringify(this.labels)) {
                    break;
                }
            }

            return this;
        }

        analyzeCluster(clusterIndex, data, featureNames) {
            const clusterPoints = data.filter((_, i) => this.labels[i] === clusterIndex);

            if (clusterPoints.length === 0) return null;

            const stats = featureNames.map((name, featureIndex) => {
                const values = clusterPoints.map(point => point[featureIndex]);
                const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                const min = Math.min(...values);
                const max = Math.max(...values);

                return { name, mean, min, max };
            });

            return {
                size: clusterPoints.length,
                stats: stats
            };
        }
    }

    function generateClusteringRules() {
        const { data } = preprocessData();

        if (data.length < 5) {
            return [{
                name: "æ•°æ®ä¸è¶³",
                conditions: "æ•°æ®æ ·æœ¬æ•°é‡å¤ªå°‘ï¼Œæ— æ³•è¿›è¡Œèšç±»åˆ†æ",
                confidence: 0,
                category: "è­¦å‘Š"
            }];
        }

        const nClusters = parseInt(document.getElementById('n_clusters').value) || 5;

        // å‡†å¤‡ç‰¹å¾æ•°æ®
        const featureNames = selectedColumns.features;
        const X = data.map(row =>
            featureNames.map(feature => row[feature])
        );

        // æ ‡å‡†åŒ–æ•°æ®
        const means = featureNames.map((_, i) =>
            X.reduce((sum, row) => sum + row[i], 0) / X.length);
        const stds = featureNames.map((_, i) => {
            const mean = means[i];
            const variance = X.reduce((sum, row) => sum + Math.pow(row[i] - mean, 2), 0) / X.length;
            return Math.sqrt(variance) || 1;
        });

        const normalizedX = X.map(row =>
            row.map((val, i) => (val - means[i]) / stds[i])
        );

        // æ‰§è¡ŒK-meansèšç±»
        const kmeans = new KMeansCluster(nClusters);
        kmeans.fit(normalizedX);

        // ç”Ÿæˆè§„åˆ™
        const rules = [];
        for (let cluster = 0; cluster < nClusters; cluster++) {
            const analysis = kmeans.analyzeCluster(cluster, normalizedX, featureNames);

            if (!analysis || analysis.size === 0) continue;

            // æ‰¾å‡ºæ¯ä¸ªèšç±»çš„æ˜¾è‘—ç‰¹å¾
            const significantFeatures = analysis.stats
                .map((stat, i) => ({ ...stat, index: i }))
                .filter(stat => Math.abs(stat.mean) > 0.5) // æ ‡å‡†åŒ–åå¤§äº0.5ç®—æ˜¾è‘—
                .sort((a, b) => Math.abs(b.mean) - Math.abs(a.mean))
                .slice(0, 3);

            if (significantFeatures.length > 0) {
                const conditions = significantFeatures.map(feature => {
                    const direction = feature.mean > 0 ? "é«˜" : "ä½";
                    const originalMean = feature.mean * stds[feature.index] + means[feature.index];
                    return `${feature.name}${direction}(çº¦${originalMean.toFixed(2)})`;
                }).join(', ');

                rules.push({
                    name: `èšç±»${cluster + 1}æ¨¡å¼`,
                    conditions: `èšç±»ç‰¹å¾: ${conditions}`,
                    confidence: analysis.size / data.length,
                    clusterSize: analysis.size,
                    category: `èšç±»${cluster + 1}`
                });
            }
        }

        return rules.length > 0 ? rules : [{
            name: "æœªå‘ç°æ˜æ˜¾èšç±»æ¨¡å¼",
            conditions: "æ•°æ®å¯èƒ½åˆ†å¸ƒè¾ƒä¸ºå‡åŒ€ï¼Œæœªå‘ç°æ˜¾è‘—çš„èšç±»æ¨¡å¼",
            confidence: 0,
            category: "ä¿¡æ¯"
        }];
    }

    // éšæœºæ£®æ—å®ç°
    class RandomForest {
        constructor(nEstimators = 10, maxDepth = 5, maxFeatures = 0.8, maxSamples = 0.8) {
            this.nEstimators = nEstimators;
            this.maxDepth = maxDepth;
            this.maxFeatures = maxFeatures;
            this.maxSamples = maxSamples;
            this.trees = [];
            this.featureImportances = {};
        }

        // Bootstrapé‡‡æ ·
        bootstrap(X, y) {
            const sampleSize = Math.floor(X.length * this.maxSamples);
            const indices = [];

            for (let i = 0; i < sampleSize; i++) {
                indices.push(Math.floor(Math.random() * X.length));
            }

            return {
                X: indices.map(i => X[i]),
                y: indices.map(i => y[i])
            };
        }

        // éšæœºç‰¹å¾é€‰æ‹©
        selectRandomFeatures(features) {
            const nFeatures = Math.floor(features.length * this.maxFeatures);
            const shuffled = [...features].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, nFeatures);
        }

        fit(X, y) {
            const allFeatures = Object.keys(X[0]);
            this.featureImportances = {};
            allFeatures.forEach(feature => this.featureImportances[feature] = 0);

            this.trees = [];

            for (let i = 0; i < this.nEstimators; i++) {
                // Bootstrapé‡‡æ ·
                const { X: bootX, y: bootY } = this.bootstrap(X, y);

                // éšæœºç‰¹å¾é€‰æ‹©
                const selectedFeatures = this.selectRandomFeatures(allFeatures);

                // è¿‡æ»¤ç‰¹å¾
                const filteredX = bootX.map(row => {
                    const filtered = {};
                    selectedFeatures.forEach(feature => {
                        filtered[feature] = row[feature];
                    });
                    return filtered;
                });

                // è®­ç»ƒå†³ç­–æ ‘
                const tree = new SimpleDecisionTree(this.maxDepth, 2);
                tree.fit(filteredX, bootY);

                this.trees.push({
                    tree: tree,
                    features: selectedFeatures
                });

                // ç´¯è®¡ç‰¹å¾é‡è¦æ€§ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
                selectedFeatures.forEach(feature => {
                    this.featureImportances[feature] += 1 / this.nEstimators;
                });
            }

            return this;
        }

        // æå–ç»¼åˆè§„åˆ™
        extractEnsembleRules() {
            const rules = [];

            // åŸºäºç‰¹å¾é‡è¦æ€§çš„è§„åˆ™
            const sortedFeatures = Object.entries(this.featureImportances)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 5);

            if (sortedFeatures.length > 0) {
                const featureList = sortedFeatures
                    .map(([feature, importance]) => `${feature}(${importance.toFixed(2)})`)
                    .join(' + ');

                rules.push({
                    name: "ç‰¹å¾é‡è¦æ€§ç»¼åˆè§„åˆ™",
                    conditions: `åŸºäºéšæœºæ£®æ—ç‰¹å¾é‡è¦æ€§: ${featureList}`,
                    confidence: 0.9,
                    feature_importance: Object.fromEntries(sortedFeatures),
                    category: "ç»¼åˆè¯„åˆ†"
                });
            }

            // ä»å„ä¸ªæ ‘ä¸­æå–é«˜ç½®ä¿¡åº¦è§„åˆ™
            const allTreeRules = [];
            this.trees.forEach((treeData, index) => {
                const treeRules = treeData.tree.rules
                    .filter(rule => rule.confidence > 0.7)
                    .slice(0, 2);

                treeRules.forEach(rule => {
                    allTreeRules.push({
                        ...rule,
                        name: `æ£®æ—è§„åˆ™ ${allTreeRules.length + 1}`,
                        conditions: `æ ‘${index + 1}: ${rule.conditions}`,
                        category: "æ£®æ—æŠ•ç¥¨"
                    });
                });
            });

            // é€‰æ‹©æœ€å¥½çš„æ ‘è§„åˆ™
            const topTreeRules = allTreeRules
                .sort((a, b) => b.confidence - a.confidence)
                .slice(0, 3);

            return [...rules, ...topTreeRules];
        }
    }

    function generateRandomForestRules() {
        const { data } = preprocessData();

        if (data.length < 10) {
            return [{
                name: "æ•°æ®ä¸è¶³",
                conditions: "æ•°æ®æ ·æœ¬æ•°é‡å¤ªå°‘ï¼Œæ— æ³•æ„å»ºéšæœºæ£®æ—",
                confidence: 0,
                category: "è­¦å‘Š"
            }];
        }

        const nEstimators = parseInt(document.getElementById('n_estimators').value) || 10;
        const maxDepth = parseInt(document.getElementById('rf_max_depth').value) || 10;
        const maxFeatures = parseFloat(document.getElementById('max_features').value) || 0.8;
        const maxSamples = parseFloat(document.getElementById('max_samples').value) || 0.8;

        const X = data.map(row => {
            const features = {};
            selectedColumns.features.forEach(feature => {
                features[feature] = row[feature];
            });
            return features;
        });

        const y = data.map(row => row.target);

        try {
            const forest = new RandomForest(nEstimators, maxDepth, maxFeatures, maxSamples);
            forest.fit(X, y);

            const rules = forest.extractEnsembleRules();

            return rules.length > 0 ? rules : [{
                name: "éšæœºæ£®æ—è®­ç»ƒå®Œæˆ",
                conditions: "éšæœºæ£®æ—è®­ç»ƒå®Œæˆï¼Œä½†æœªæå–åˆ°æ˜¾è‘—è§„åˆ™",
                confidence: 0,
                category: "ä¿¡æ¯"
            }];

        } catch (error) {
            return [{
                name: "éšæœºæ£®æ—é”™è¯¯",
                conditions: `éšæœºæ£®æ—è®­ç»ƒå‡ºé”™: ${error.message}`,
                confidence: 0,
                category: "é”™è¯¯"
            }];
        }
    }

    function displayGeneratedRules() {
        const output = document.getElementById('rulesOutput');
        const count = document.getElementById('ruleCount');

        count.textContent = generatedRules.length;

        output.innerHTML = generatedRules.map((rule, index) => `
                <div class="rule-item">
                    <div class="rule-header">
                        <div class="rule-name">è§„åˆ™ ${index + 1}: ${rule.name}</div>
                        <div class="rule-confidence">ç½®ä¿¡åº¦: ${(rule.confidence * 100).toFixed(1)}%</div>
                    </div>
                    <div class="rule-conditions">${rule.conditions}</div>
                    ${rule.support ? `<div style="color: #a0a0a0; font-size: 12px; margin-top: 5px;">æ”¯æŒåº¦: ${(rule.support * 100).toFixed(1)}%</div>` : ''}
                    ${rule.lift ? `<div style="color: #a0a0a0; font-size: 12px;">æå‡åº¦: ${rule.lift.toFixed(2)}</div>` : ''}
                    ${rule.clusterSize ? `<div style="color: #a0a0a0; font-size: 12px;">èšç±»å¤§å°: ${rule.clusterSize} æ ·æœ¬</div>` : ''}
                </div>
            `).join('');
    }

    // å¯¼å‡ºåŠŸèƒ½
    function exportToMainSystem() {
        const rulesForExport = generatedRules.map((rule, index) => ({
            id: Date.now() + index,
            name: rule.name,
            category: rule.category || "æ™ºèƒ½æå–",
            description: rule.conditions,
            conditions: parseRuleConditions(rule.conditions),
            weight: Math.round(rule.confidence * 100)
        }));

        // ä¿å­˜åˆ°localStorageï¼Œä¸»ç³»ç»Ÿå¯ä»¥è¯»å–
        localStorage.setItem('extractedRules', JSON.stringify(rulesForExport));

        alert(`å·²æˆåŠŸæå– ${rulesForExport.length} æ¡è§„åˆ™åˆ°ä¸»ç³»ç»Ÿï¼\n\næ‚¨å¯ä»¥è¿”å›ä¸»ç³»ç»ŸæŸ¥çœ‹å’Œç¼–è¾‘è¿™äº›è§„åˆ™ã€‚`);
    }

    function parseRuleConditions(conditionText) {
        // ç®€å•çš„æ¡ä»¶è§£æï¼Œå®é™…é¡¹ç›®ä¸­éœ€è¦æ›´å¤æ‚çš„è§£æé€»è¾‘
        const conditions = [];

        if (conditionText.includes('äº¤æ˜“é‡‘é¢')) {
            conditions.push({
                field: "äº¤æ˜“é‡‘é¢",
                operator: "å¤§äº",
                value: "100000"
            });
        }

        if (conditionText.includes('äº¤æ˜“æ—¶é—´')) {
            conditions.push({
                field: "äº¤æ˜“æ—¶é—´",
                operator: "ç­‰äº",
                value: "æ·±å¤œ"
            });
        }

        if (conditionText.includes('è´¦æˆ·ç±»å‹')) {
            conditions.push({
                field: "è´¦æˆ·ç±»å‹",
                operator: "ç­‰äº",
                value: "ä¸ªäººè´¦æˆ·"
            });
        }

        return conditions.length > 0 ? conditions : [
            { field: "ç³»ç»Ÿç”Ÿæˆ", operator: "åŸºäº", value: "æœºå™¨å­¦ä¹ ç®—æ³•" }
        ];
    }

    function exportAsJSON() {
        const dataStr = JSON.stringify(generatedRules, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = 'extracted_rules.json';
        link.click();

        URL.revokeObjectURL(url);
    }

    function exportAsCSV() {
        const headers = ['è§„åˆ™åç§°', 'æ¡ä»¶', 'ç½®ä¿¡åº¦', 'ç±»åˆ«'];
        const csvContent = [
            headers.join(','),
            ...generatedRules.map(rule => [
                rule.name,
                `"${rule.conditions}"`,
                rule.confidence,
                rule.category || ''
            ].join(','))
        ].join('\n');

        const dataBlob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = 'extracted_rules.csv';
        link.click();

        URL.revokeObjectURL(url);
    }

    // åˆå§‹åŒ–åº”ç”¨
    init();</script>